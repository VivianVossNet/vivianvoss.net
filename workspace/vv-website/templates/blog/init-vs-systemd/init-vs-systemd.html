{! extends "../../_base.html" | slotlist !}

{( slot title )}Service Management: init vs systemd &#x2014; Vivian Voss{( endslot )}

{( slot meta )}
<meta name="description" content="FreeBSD init runs on 178 shell scripts and one shared library. systemd ships 690,000 lines of C across 150 compiled binaries. Both start services. One of them also replaced sudo.">
{( endslot )}

{( slot canonical )}/blog/init-vs-systemd{( endslot )}

{( slot og-title )}Service Management: init vs systemd &#x2014; Vivian Voss{( endslot )}

{( slot og-desc )}FreeBSD init runs on 178 shell scripts and one shared library. systemd ships 690,000 lines of C across 150 compiled binaries. Both start services.{( endslot )}

{( slot jsonld )}<script type="application/ld+json">{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Service Management: init vs systemd",
    "datePublished": "2026-02-16",
    "author": { "@id": "https://vivianvoss.net/#person" },
    "publisher": { "@id": "https://vivianvoss.net/#person" },
    "url": "https://vivianvoss.net/blog/init-vs-systemd",
    "description": "FreeBSD init runs on 178 shell scripts and one shared library. systemd ships 690,000 lines of C across 150 compiled binaries. Both start services. One of them also replaced sudo.",
    "inLanguage": "en-GB",
    "isPartOf": { "@id": "https://vivianvoss.net/#website" }
}</script>{( endslot )}

{( slot content )}
<article class="vv-article">
    <header class="vv-article-header">
        <p class="vv-article-meta">
            <time datetime="2026-02-16">16 February 2026</time>
            <span aria-hidden="true">&#x25A0;</span>
            <a href="https://www.linkedin.com/in/vvoss/" target="_blank" rel="noopener">Read on LinkedIn</a>
        </p>
        <h1>Service Management: init vs systemd</h1>
    </header>

    <div class="vv-article-body">
        <p><em>The Unix Way</em> &#x25A0; Episode 04</p>

        <p>
            A service starts. It stops. It restarts if it crashes. It declares its
            dependencies so the system knows the order. That is the job description.
            It has not changed since the 1980s. What has changed &#x2014; rather
            dramatically &#x2014; is the amount of C required to accomplish it.
        </p>

        <p>
            On <a href="https://docs.freebsd.org/en/articles/rc-scripting/" target="_blank" rel="noopener">FreeBSD</a>,
            a service is a shell script. Ten lines, typically. It sources one shared
            library &#x2014; <code>rc.subr</code> &#x2014; declares <code>REQUIRE</code>,
            <code>BEFORE</code>, and <code>AFTER</code> for dependency ordering, reads
            its configuration from a single file (<code>/etc/rc.conf</code>), and is
            sorted at boot by one C utility: <code>rcorder</code>. The entire init
            system amounts to 178 shell scripts. You debug it with <code>sh -x</code>,
            <code>cat</code>, and <code>grep</code>.
        </p>

        <p>
            On Linux, since 2010,
            <a href="https://www.theregister.com/2025/02/06/14_years_of_systemd/" target="_blank" rel="noopener">systemd</a>
            has replaced this arrangement with approximately 690,000 lines of compiled C,
            <a href="https://www.phoronix.com/news/systemd-Git-Stats-EOY-2024" target="_blank" rel="noopener">2.06 million total lines</a>
            across 6,363 files, and roughly 150 compiled binaries. In 2024 alone, it
            received 8,397 commits. Both systems start services. One of them also replaced
            <code>sudo</code>.
        </p>

        <h2>The Anatomy</h2>

        <p>
            The comparison is best understood structurally. FreeBSD&#x2019;s init system
            is composed of precisely five elements: shell scripts, one library, one
            configuration file, one ordering utility, and the shell itself. Each is
            inspectable, replaceable, and debuggable with tools that predate the engineer
            using them.
        </p>

        <p>
            systemd is composed of &#x2014; well, rather more. The binary count stood at
            69 in 2013, which prompted some concern. By 2024, it had doubled. The project
            absorbed fifteen distinct tools that previously existed as independent,
            single-purpose programs, each maintained by specialists who understood them
            intimately.
        </p>

        <!-- Comparison: FreeBSD init vs systemd architecture -->
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 520 380" role="img" aria-label="Architecture comparison: FreeBSD init consists of 5 components totalling 178 shell scripts. systemd consists of 150-plus compiled binaries totalling 690,000 lines of C." style="max-width: 520px; width: 100%; height: auto; margin: 2em 0;">
            <style>
                .init-label { font: 600 11px/1 'Oxanium', system-ui, sans-serif; fill: var(--text); }
                .init-title { font: 700 12px/1 'Oxanium', system-ui, sans-serif; }
                .init-muted { font: 400 10px/1 'Oxanium', system-ui, sans-serif; fill: var(--muted); }
                .init-value { font: 700 13px/1 'Oxanium', system-ui, sans-serif; fill: var(--accent); }
                .init-box { fill: none; stroke: var(--border); stroke-width: 1; rx: 3; }
                .init-box-accent { fill: none; stroke: var(--accent); stroke-width: 1.5; rx: 3; }
            </style>

            <!-- Left: FreeBSD init -->
            <text class="init-title" x="130" y="20" text-anchor="middle" fill="var(--accent)">FreeBSD init</text>
            <text class="init-muted" x="130" y="36" text-anchor="middle">5 components</text>

            <rect class="init-box-accent" x="20" y="50" width="220" height="36"/>
            <text class="init-label" x="130" y="73" text-anchor="middle">178 shell scripts</text>

            <rect class="init-box-accent" x="20" y="94" width="220" height="36"/>
            <text class="init-label" x="130" y="117" text-anchor="middle">rc.subr (1 shared library)</text>

            <rect class="init-box-accent" x="20" y="138" width="220" height="36"/>
            <text class="init-label" x="130" y="161" text-anchor="middle">rc.conf (1 config file)</text>

            <rect class="init-box-accent" x="20" y="182" width="220" height="36"/>
            <text class="init-label" x="130" y="205" text-anchor="middle">rcorder (1 C binary)</text>

            <rect class="init-box-accent" x="20" y="226" width="220" height="36"/>
            <text class="init-label" x="130" y="249" text-anchor="middle">/bin/sh</text>

            <text class="init-value" x="130" y="290" text-anchor="middle">Debug: sh -x, cat, grep</text>
            <text class="init-muted" x="130" y="308" text-anchor="middle">Tools you already know.</text>

            <!-- Right: systemd -->
            <text class="init-title" x="390" y="20" text-anchor="middle" fill="var(--muted)">systemd</text>
            <text class="init-muted" x="390" y="36" text-anchor="middle">150+ compiled binaries</text>

            <rect class="init-box" x="280" y="50" width="220" height="28"/>
            <text class="init-muted" x="390" y="69" text-anchor="middle">systemd (PID 1)</text>
            <rect class="init-box" x="280" y="82" width="220" height="28"/>
            <text class="init-muted" x="390" y="101" text-anchor="middle">journald (logs)</text>
            <rect class="init-box" x="280" y="114" width="220" height="28"/>
            <text class="init-muted" x="390" y="133" text-anchor="middle">logind (sessions)</text>
            <rect class="init-box" x="280" y="146" width="220" height="28"/>
            <text class="init-muted" x="390" y="165" text-anchor="middle">networkd (DHCP, DNS)</text>
            <rect class="init-box" x="280" y="178" width="220" height="28"/>
            <text class="init-muted" x="390" y="197" text-anchor="middle">timesyncd (NTP)</text>
            <rect class="init-box" x="280" y="210" width="220" height="28"/>
            <text class="init-muted" x="390" y="229" text-anchor="middle">udevd (devices)</text>
            <rect class="init-box" x="280" y="242" width="105" height="28"/>
            <text class="init-muted" x="332" y="261" text-anchor="middle">run0</text>
            <rect class="init-box" x="395" y="242" width="105" height="28"/>
            <text class="init-muted" x="447" y="261" text-anchor="middle">+140 more</text>

            <text class="init-muted" x="390" y="296" text-anchor="middle" style="fill: var(--muted);">690,000 SLOC &#x2022; 6,363 files</text>
            <text class="init-muted" x="390" y="312" text-anchor="middle">2.06M total lines &#x2022; 8,397 commits (2024)</text>

            <!-- Bottom comparison -->
            <line x1="20" y1="340" x2="500" y2="340" stroke="var(--border)" stroke-width="0.5" stroke-dasharray="4 3"/>
            <rect x="20" y="354" width="8" height="14" rx="1" fill="var(--accent)"/>
            <text class="init-muted" x="34" y="366">FreeBSD init</text>
            <rect x="130" y="354" width="300" height="14" rx="1" fill="var(--border)" opacity="0.4"/>
            <text class="init-muted" x="438" y="366">systemd</text>
        </svg>

        <p>
            The ratio is instructive not because bigger is necessarily worse &#x2014;
            complexity has legitimate uses &#x2014; but because both systems solve
            the same problem. The question is whether the additional 689,800 lines
            of C purchase something the shell scripts cannot provide, or whether they
            purchase something nobody asked for.
        </p>

        <h2>The Absorption</h2>

        <p>
            systemd did not merely replace <code>SysVinit</code>. It absorbed the tools
            that surrounded it. One by one, independent utilities that had operated
            perfectly well for decades were subsumed into a single project under a single
            maintainer. The toll:
        </p>

        <p>
            <code>syslog</code> became <code>journald</code>.
            <code>cron</code> became systemd timers.
            <code>inetd</code> became socket activation.
            <code>udev</code> was absorbed wholesale.
            <code>ConsoleKit</code> became <code>logind</code>.
            NTP became <code>timesyncd</code>.
            DHCP became <code>networkd</code>.
            And in 2024, <code>sudo</code> &#x2014; a thirty-four-year-old privilege
            escalation tool &#x2014; was deemed insufficiently integrated. Enter
            <a href="https://www.theregister.com/2025/02/06/14_years_of_systemd/" target="_blank" rel="noopener"><code>run0</code></a>,
            systemd&#x2019;s replacement for the programme that lets you become root.
        </p>

        <p>
            Fifteen tools absorbed. Each previously maintained by domain experts. Each
            with its own release cycle, its own bug tracker, its own community of people
            who understood it deeply. All now governed by one project, one repository,
            one set of conventions, and one opinion about how a Linux system should
            behave.
        </p>

        <p>
            On FreeBSD, <code>syslog</code> is still <code>syslog</code>.
            <code>cron</code> is still <code>cron</code>. <code>ntpd</code> is still
            <code>ntpd</code>. Each does one thing. Each is replaceable without
            rearchitecting the rest. This is not conservatism. It is the Unix philosophy
            operating as designed: small tools, loosely joined, each earning its place.
        </p>

        <h2>The Log Problem</h2>

        <p>
            Your server crashes. The filesystem is intact, but the service that was
            running has stopped and you need to know why. On FreeBSD, the answer is
            waiting for you in <code>/var/log/messages</code>. Plain text. You open it
            with <code>grep</code>, <code>awk</code>, or <code>tail</code>. The tools
            work because they always work. They have no dependencies, no state, no
            opinions about the health of the system they are inspecting.
        </p>

        <p>
            On a systemd machine, the logs are in the journal. The journal is binary.
            To read it, you need <code>journalctl</code> &#x2014; which requires a
            functioning systemd, which requires a functioning D-Bus, which requires the
            very system you are trying to diagnose. If the journal has corrupted
            &#x2014; and it does &#x2014; you are reading binary with <code>hexdump</code>
            and rather wishing you were not.
        </p>

        <!-- Log access comparison -->
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 520 260" role="img" aria-label="Log access after a crash: FreeBSD uses plain text files readable with grep and awk. systemd uses binary journals requiring a working journalctl and D-Bus." style="max-width: 520px; width: 100%; height: auto; margin: 2em 0;">
            <style>
                .log-label { font: 600 11px/1 'Oxanium', system-ui, sans-serif; fill: var(--text); }
                .log-title { font: 700 12px/1 'Oxanium', system-ui, sans-serif; }
                .log-muted { font: 400 10px/1 'Oxanium', system-ui, sans-serif; fill: var(--muted); }
                .log-mono { font: 400 10.5px/1 ui-monospace, monospace; fill: var(--text); }
                .log-box { fill: none; stroke: var(--border); stroke-width: 1; rx: 3; }
                .log-box-accent { fill: none; stroke: var(--accent); stroke-width: 1.5; rx: 3; }
                .log-arrow { stroke: var(--accent); stroke-width: 1.5; fill: none; marker-end: url(#log-arr); }
                .log-arrow-dim { stroke: var(--muted); stroke-width: 1; fill: none; marker-end: url(#log-arr-dim); }
            </style>
            <defs>
                <marker id="log-arr" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="7" markerHeight="5" orient="auto-start-reverse">
                    <polygon points="0 0, 10 3.5, 0 7" fill="var(--accent)"/>
                </marker>
                <marker id="log-arr-dim" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="7" markerHeight="5" orient="auto-start-reverse">
                    <polygon points="0 0, 10 3.5, 0 7" fill="var(--muted)"/>
                </marker>
            </defs>

            <text class="log-title" x="260" y="18" text-anchor="middle" fill="var(--text)">After a crash: reading the logs</text>

            <!-- Left: FreeBSD -->
            <text class="log-title" x="130" y="46" text-anchor="middle" fill="var(--accent)">FreeBSD</text>

            <rect class="log-box-accent" x="30" y="58" width="200" height="32"/>
            <text class="log-mono" x="130" y="79" text-anchor="middle">/var/log/messages</text>
            <text class="log-muted" x="130" y="105" text-anchor="middle">Plain text. Always there.</text>

            <line class="log-arrow" x1="130" y1="114" x2="130" y2="134"/>

            <rect class="log-box-accent" x="30" y="136" width="200" height="32"/>
            <text class="log-mono" x="130" y="157" text-anchor="middle">grep | awk | tail</text>
            <text class="log-muted" x="130" y="183" text-anchor="middle">No dependencies. Works offline.</text>

            <text class="log-label" x="130" y="210" text-anchor="middle" style="fill: var(--accent);">Answer in seconds.</text>

            <!-- Right: systemd -->
            <text class="log-title" x="390" y="46" text-anchor="middle" fill="var(--muted)">systemd</text>

            <rect class="log-box" x="290" y="58" width="200" height="32"/>
            <text class="log-mono" x="390" y="79" text-anchor="middle">/var/log/journal/*</text>
            <text class="log-muted" x="390" y="105" text-anchor="middle">Binary format. Requires tooling.</text>

            <line class="log-arrow-dim" x1="390" y1="114" x2="390" y2="134"/>

            <rect class="log-box" x="290" y="136" width="200" height="32"/>
            <text class="log-mono" x="390" y="157" text-anchor="middle">journalctl</text>

            <line class="log-arrow-dim" x1="390" y1="168" x2="390" y2="186"/>

            <rect class="log-box" x="310" y="188" width="70" height="24"/>
            <text class="log-muted" x="345" y="205" text-anchor="middle">systemd</text>
            <rect class="log-box" x="390" y="188" width="70" height="24"/>
            <text class="log-muted" x="425" y="205" text-anchor="middle">D-Bus</text>

            <text class="log-muted" x="390" y="236" text-anchor="middle">Requires the system you are diagnosing.</text>
            <text class="log-muted" x="390" y="252" text-anchor="middle">Corrupts? Good luck with hexdump.</text>
        </svg>

        <p>
            <a href="https://lkml.org/lkml/2014/1/16/327" target="_blank" rel="noopener">Linus Torvalds</a>
            was characteristically direct: &#x201C;I think some of the design details
            are insane. I dislike the binary logs.&#x201D; One does not often find
            oneself in the position of calling the Linux kernel maintainer a master
            of understatement, but here we are.
        </p>

        <p>
            Plain text logs are not a limitation. They are a feature. They compose
            with every tool in the Unix ecosystem. They survive filesystem damage
            that binary formats do not. They can be shipped, piped, searched, and
            read by a human being with no special tooling and no functioning init
            system. The decision to replace them with a proprietary binary format
            was not an upgrade. It was a dependency injection.
        </p>

        <h2>The PID 1 Question</h2>

        <p>
            PID 1 is the first process the kernel starts. If PID 1 crashes, the kernel
            panics. There is no recovery. There is no fallback. The machine stops. This
            is not a design flaw. It is a contract: PID 1 must be so simple, so minimal,
            so thoroughly understood that it <em>cannot</em> fail.
        </p>

        <p>
            FreeBSD&#x2019;s <code>init</code> honours this contract.
            <a href="https://ewontfix.com/14/" target="_blank" rel="noopener">Rich Felker</a>,
            the author of musl libc, observed that a correct PID 1 can be written in
            roughly fifteen lines of C. Fork. Reap zombies. Wait. That is the entire
            job. FreeBSD&#x2019;s init is not much larger. It does not parse D-Bus
            messages. It does not manage network interfaces. It does not handle device
            hotplug. It starts processes and reaps their children. Full stop.
        </p>

        <p>
            systemd&#x2019;s PID 1 is a D-Bus client. It manages a state machine. It
            processes notifications. It handles socket activation. It is, by any reasonable
            measure, a complex application running as the one process that must never fail.
        </p>

        <p>
            In 2016, this architectural choice bore its most instructive fruit. An
            unprivileged user &#x2014; not root, not a daemon, an ordinary user &#x2014;
            could
            <a href="https://agwa.name/blog/post/how_to_crash_systemd_in_one_tweet" target="_blank" rel="noopener">hang PID 1</a>
            by sending an empty D-Bus message. One message. Zero bytes of payload.
            PID 1 stopped responding. SSH hung. A clean reboot became impossible. The
            machine required a hard power cycle.
        </p>

        <blockquote>
            <p>SIGKILL will not help. PID 1 is exempt from signals it does not explicitly
                handle. The process did not crash. It simply stopped doing its job, which
                is arguably worse.</p>
        </blockquote>

        <!-- PID 1 responsibility comparison -->
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 520 300" role="img" aria-label="PID 1 responsibilities: FreeBSD init does three things (fork, reap, wait). systemd PID 1 does D-Bus, state machine, socket activation, notifications, device management, and more." style="max-width: 520px; width: 100%; height: auto; margin: 2em 0;">
            <style>
                .pid-label { font: 600 11px/1 'Oxanium', system-ui, sans-serif; fill: var(--text); }
                .pid-title { font: 700 12px/1 'Oxanium', system-ui, sans-serif; }
                .pid-muted { font: 400 10px/1 'Oxanium', system-ui, sans-serif; fill: var(--muted); }
                .pid-value { font: 700 11px/1 'Oxanium', system-ui, sans-serif; fill: var(--accent); }
                .pid-box { fill: none; stroke: var(--border); stroke-width: 1; rx: 3; }
                .pid-box-accent { fill: none; stroke: var(--accent); stroke-width: 1.5; rx: 3; }
                .pid-warn { fill: var(--accent); opacity: 0.1; rx: 4; }
            </style>

            <text class="pid-title" x="260" y="18" text-anchor="middle" fill="var(--text)">PID 1 &#x2014; the process that must never fail</text>
            <text class="pid-muted" x="260" y="34" text-anchor="middle">Crash = kernel panic. No recovery.</text>

            <!-- Left: FreeBSD -->
            <text class="pid-title" x="130" y="60" text-anchor="middle" fill="var(--accent)">FreeBSD init</text>

            <rect class="pid-box-accent" x="40" y="72" width="180" height="30"/>
            <text class="pid-label" x="130" y="92" text-anchor="middle">fork()</text>

            <rect class="pid-box-accent" x="40" y="108" width="180" height="30"/>
            <text class="pid-label" x="130" y="128" text-anchor="middle">reap zombies</text>

            <rect class="pid-box-accent" x="40" y="144" width="180" height="30"/>
            <text class="pid-label" x="130" y="164" text-anchor="middle">wait()</text>

            <text class="pid-value" x="130" y="200" text-anchor="middle">~15 lines of C</text>
            <text class="pid-muted" x="130" y="216" text-anchor="middle">Attack surface: effectively zero</text>

            <!-- Right: systemd -->
            <text class="pid-title" x="390" y="60" text-anchor="middle" fill="var(--muted)">systemd PID 1</text>

            <rect class="pid-warn" x="280" y="70" width="220" height="200"/>

            <rect class="pid-box" x="290" y="78" width="100" height="24"/>
            <text class="pid-muted" x="340" y="95" text-anchor="middle">D-Bus client</text>
            <rect class="pid-box" x="400" y="78" width="90" height="24"/>
            <text class="pid-muted" x="445" y="95" text-anchor="middle">State machine</text>

            <rect class="pid-box" x="290" y="108" width="100" height="24"/>
            <text class="pid-muted" x="340" y="125" text-anchor="middle">Socket activ.</text>
            <rect class="pid-box" x="400" y="108" width="90" height="24"/>
            <text class="pid-muted" x="445" y="125" text-anchor="middle">Notifications</text>

            <rect class="pid-box" x="290" y="138" width="100" height="24"/>
            <text class="pid-muted" x="340" y="155" text-anchor="middle">cgroup mgmt</text>
            <rect class="pid-box" x="400" y="138" width="90" height="24"/>
            <text class="pid-muted" x="445" y="155" text-anchor="middle">Devices</text>

            <rect class="pid-box" x="290" y="168" width="100" height="24"/>
            <text class="pid-muted" x="340" y="185" text-anchor="middle">Logging</text>
            <rect class="pid-box" x="400" y="168" width="90" height="24"/>
            <text class="pid-muted" x="445" y="185" text-anchor="middle">Mount mgmt</text>

            <rect class="pid-box" x="290" y="198" width="200" height="24"/>
            <text class="pid-muted" x="390" y="215" text-anchor="middle">DNS, NTP, DHCP, containers, sudo...</text>

            <text class="pid-muted" x="390" y="250" text-anchor="middle" style="fill: var(--muted);">2016: empty D-Bus message hung PID 1</text>
            <text class="pid-muted" x="390" y="266" text-anchor="middle">SSH dead. Clean reboot impossible.</text>
            <text class="pid-muted" x="390" y="282" text-anchor="middle">Unprivileged user. Zero bytes payload.</text>
        </svg>

        <p>
            The question is not whether systemd&#x2019;s PID 1 is well-written. The
            question is whether PID 1 should also be a DNS resolver, a log daemon, a
            device manager, a container runtime, a session tracker, and &#x2014; as of
            2024 &#x2014; a sudo replacement. The Unix answer is no. Not because these
            are bad functions, but because PID 1 is the wrong place to put them. A
            fifteen-line process cannot have a D-Bus vulnerability. It cannot be hung by
            a zero-byte message. It cannot fail in ways its authors did not anticipate,
            because there is almost nothing there to fail.
        </p>

        <h2>The Numbers, Plainly</h2>

        <p>
            The Phoronix end-of-year statistics for
            <a href="https://www.phoronix.com/news/systemd-Git-Stats-EOY-2024" target="_blank" rel="noopener">systemd in 2024</a>
            read less like a service manager and more like a mid-sized application
            framework:
        </p>

        <p>
            690,000 lines of source code. 2,060,000 total lines including tests,
            documentation, and build configuration. 6,363 files. 8,397 commits in a
            single calendar year. The project has more lines of code than many of the
            applications it manages.
        </p>

        <p>
            FreeBSD&#x2019;s <code>rc.d</code> system, by contrast, has not required
            a rewrite since it was introduced. The shell scripts are the same shell
            scripts. <code>rc.subr</code> is the same library. <code>rcorder</code>
            is the same binary. The system is not maintained because it is loved. It is
            stable because there is nothing left to break.
        </p>

        <h2>The Uncomfortable Inheritance</h2>

        <p>
            The most instructive aspect of systemd is not what it does but what it
            reveals about the industry&#x2019;s relationship with complexity. When
            Lennart Poettering proposed systemd, he argued that shell scripts were
            slow, fragile, and unparseable. These were legitimate criticisms &#x2014;
            SysVinit had genuine weaknesses. The response, however, was not to fix
            the shell scripts. It was to replace the entire ecosystem with a monolithic
            suite that now performs the functions of fifteen previously independent tools.
        </p>

        <p>
            This is not the Unix way. The Unix way is to fix the tool, not absorb the
            toolbox. When <code>cron</code> is insufficient, you improve <code>cron</code>
            or write a better <code>cron</code>. You do not fold job scheduling into
            PID 1. When <code>syslog</code> is inadequate, you write a better logger.
            You do not replace text files with a binary format that requires the system
            it logs to be functional before the logs can be read.
        </p>

        <p>
            FreeBSD demonstrates that the alternative is not theoretical. It is
            running. It has been running. The services start. The dependencies resolve.
            The logs are readable after a crash. The init process is small enough to
            audit in an afternoon. No D-Bus. No binary journals. No sudo replacement
            in PID 1.
        </p>

        <blockquote>
            <p>The job of an init system is to start services and stay out of the way.
                FreeBSD&#x2019;s init does this with shell scripts, one library, and one
                C binary. systemd does this with 690,000 lines of C and a growing
                conviction that every system utility should live under one roof. The
                services start either way. The question is what else you are running
                &#x2014; and what happens when it breaks.</p>
        </blockquote>
    </div>

    <footer class="vv-article-footer">
        <a href="/blog">&#x2190; All articles</a>
    </footer>
</article>
{( endslot )}