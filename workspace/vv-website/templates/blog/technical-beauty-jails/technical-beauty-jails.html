{! extends "../../_base.html" | slotlist !}

{( slot title )}Technical Beauty: FreeBSD Jails &#x2014; Vivian Voss{( endslot )}

{( slot meta )}
<meta name="description" content="Poul-Henning Kamp built FreeBSD Jails in 1999. Kernel-level isolation, near-zero overhead, native ZFS integration. Stable API for 25 years. No daemon, no overlay network, no orchestration layer. 14 years before Docker, the problem was already solved.">
{( endslot )}

{( slot canonical )}/blog/technical-beauty-jails{( endslot )}

{( slot og-title )}Technical Beauty: FreeBSD Jails &#x2014; Vivian Voss{( endslot )}

{( slot og-desc )}Poul-Henning Kamp built FreeBSD Jails in 1999. Kernel-level isolation, near-zero overhead, native ZFS integration. Stable API for 25 years. No daemon, no overlay. 14 years before Docker.{( endslot )}

{( slot jsonld )}<script type="application/ld+json">{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Technical Beauty: FreeBSD Jails",
    "datePublished": "2026-01-06",
    "author": { "@id": "https://vivianvoss.net/#person" },
    "publisher": { "@id": "https://vivianvoss.net/#person" },
    "url": "https://vivianvoss.net/blog/technical-beauty-jails",
    "description": "Poul-Henning Kamp built FreeBSD Jails in 1999. Kernel-level isolation, near-zero overhead, native ZFS integration. Stable API for 25 years. No daemon, no overlay network, no orchestration layer. 14 years before Docker, the problem was already solved.",
    "inLanguage": "en-GB",
    "isPartOf": { "@id": "https://vivianvoss.net/#website" }
}</script>{( endslot )}

{( slot content )}
<article class="vv-article">
    <header class="vv-article-header">
        <p class="vv-article-meta">
            <time datetime="2026-01-06">6 January 2026</time>
            <span aria-hidden="true">&#x25A0;</span>
            <a href="https://www.linkedin.com/in/vvoss/" target="_blank" rel="noopener">Read on LinkedIn</a>
        </p>
        <h1>Technical Beauty: FreeBSD Jails</h1>
        <div class="vv-pills">
            <span class="vv-pill">freebsd</span>
            <span class="vv-pill">architecture</span>
            <span class="vv-pill">unix</span>
        </div>
    </header>

    <div class="vv-article-body">
        <p><em>Technical Beauty</em> &#x25A0; Episode 04</p>

        <p>In 1999, a Danish programmer solved a problem. Not a fashionable
            problem. Not a problem that would attract venture capital or inspire
            a logo with a whale on it. A real problem: <code>chroot</code>
            was not secure enough for multi-tenant hosting.</p>

        <p><a href="https://en.wikipedia.org/wiki/Poul-Henning_Kamp" target="_blank" rel="noopener">Poul-Henning Kamp</a>
            built
            <a href="https://en.wikipedia.org/wiki/FreeBSD_jail" target="_blank" rel="noopener">FreeBSD Jails</a>.
            Kernel-level process isolation. Near-zero overhead. No daemon.
            No overlay network. No orchestration layer. No YAML. The solution
            shipped in
            <a href="https://www.freebsd.org/releases/4.0R/announce/" target="_blank" rel="noopener">FreeBSD 4.0</a>
            in March 2000, and the API has not broken since.</p>

        <p>Fourteen years later, Docker arrived with considerably more
            fanfare and considerably more moving parts. The industry
            declared containerisation a revolution. FreeBSD administrators
            checked the date and carried on.</p>

        <h2>The Problem</h2>

        <p>The Unix <code>chroot</code> system call, introduced in 1979,
            changes the apparent root directory for a process. It was never
            designed as a security mechanism. It was designed for building and
            testing. The name is honest: it changes the root. It does not
            isolate the process, restrict its system calls, limit its network
            access, or prevent it from escaping if it has root privileges
            inside the changed root. A process with sufficient determination
            (and <code>CAP_SYS_CHROOT</code>) can simply
            <code>chroot</code> again, walk upwards, and break free. The
            escape is well-documented, trivially reproducible, and has been
            known since the 1980s.</p>

        <p><a href="https://klarasystems.com/articles/freebsd-jails-the-beginning-of-freebsd-containers/" target="_blank" rel="noopener">R&amp;D Associates</a>,
            a hosting provider, needed proper isolation. They needed to give
            customers root access inside their own environments without
            giving them access to the host system, other customers, or the
            network stack. <code>chroot</code> could not do this. Virtual
            machines could, but at the cost of running an entire operating
            system per tenant. Kamp&#x2019;s insight was that the kernel
            already had all the necessary enforcement mechanisms. They
            simply needed to be composed correctly.</p>

        <h2>The Architecture</h2>

        <p>A jail is a partition of the kernel&#x2019;s resource namespace.
            Not a separate kernel. Not a daemon that intercepts system
            calls. Not a userspace process pretending to be an operating
            system. The FreeBSD kernel itself enforces the boundaries.
            A jailed process sees its own filesystem root, its own process
            table, its own network interfaces (via
            <a href="https://man.freebsd.org/cgi/man.cgi?query=vnet&sektion=9" target="_blank" rel="noopener">VNET</a>),
            its own users. It cannot see, signal, or interact with processes
            outside its jail. The root user inside a jail is root only
            within that jail; to the host, it is merely a confined user ID
            with delusions of authority.</p>

        <p>The implementation is startlingly direct. The
            <a href="https://papers.freebsd.org/2000/phk-jails/" target="_blank" rel="noopener">original paper</a>
            by Kamp and Robert Watson describes the mechanism in a few
            pages. The kernel maintains a jail structure per confined
            environment. System calls check the calling process&#x2019;s
            jail membership and restrict access accordingly. There is no
            interception layer. There is no ptrace-based sandboxing. There
            is no LD_PRELOAD trickery. The kernel knows. The kernel
            enforces. The boundary is not a suggestion; it is a property
            of the process itself.</p>

        <!-- Architecture comparison: Jails vs Docker -->
        <svg viewBox="0 0 520 420" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Architecture comparison between FreeBSD Jails and Docker. Jails: application sits directly on the kernel with zero intermediaries. Docker: application runs atop runc, containerd, dockerd, overlay filesystem, and iptables rules, all above the kernel." style="max-width: 520px; width: 100%; height: auto; margin: 2em 0;">
            <style>
                #jails-arch .jails-title { font: 700 13px/1 'Oxanium', system-ui, sans-serif; fill: var(--text); }
                #jails-arch .jails-label { font: 600 11px/1 'Oxanium', system-ui, sans-serif; fill: var(--text); }
                #jails-arch .jails-sub { font: 400 10px/1 'Oxanium', system-ui, sans-serif; fill: var(--muted); }
                #jails-arch .jails-accent { font: 600 11px/1 'Oxanium', system-ui, sans-serif; fill: var(--accent); }
                #jails-arch .jails-box { fill: none; stroke: var(--border); stroke-width: 1; rx: 3; }
                #jails-arch .jails-fill { fill: var(--accent); opacity: 0.08; rx: 3; }
                #jails-arch .jails-fill-hi { fill: var(--accent); opacity: 0.14; rx: 3; }
                #jails-arch .jails-fill-dim { fill: var(--muted); opacity: 0.06; rx: 3; }
                #jails-arch .jails-note { font: 400 10px/1 'Oxanium', system-ui, sans-serif; fill: var(--muted); }
                #jails-arch .jails-arrow { stroke: var(--muted); stroke-width: 1; fill: none; marker-end: url(#jails-arrowhead); }
                #jails-arch .jails-divider { stroke: var(--border); stroke-width: 0.5; stroke-dasharray: 4 3; }
            </style>
            <defs>
                <marker id="jails-arrowhead" markerWidth="6" markerHeight="4" refX="6" refY="2" orient="auto">
                    <path d="M0,0 L6,2 L0,4" fill="var(--muted)"/>
                </marker>
            </defs>
            <g id="jails-arch">
                <text class="jails-title" x="260" y="20" text-anchor="middle">Architecture: Jails vs Docker</text>
                <text class="jails-sub" x="260" y="36" text-anchor="middle">Layers between your process and the kernel</text>

                <!-- FreeBSD Jails side -->
                <text class="jails-accent" x="130" y="62" text-anchor="middle">FreeBSD Jails</text>

                <rect class="jails-fill-hi" x="30" y="74" width="200" height="40"/>
                <rect class="jails-box" x="30" y="74" width="200" height="40"/>
                <text class="jails-label" x="130" y="92" text-anchor="middle">Application</text>
                <text class="jails-sub" x="130" y="106" text-anchor="middle">pid 1 in jail</text>

                <line class="jails-arrow" x1="130" y1="114" x2="130" y2="130"/>

                <rect class="jails-fill-hi" x="30" y="132" width="200" height="40"/>
                <rect class="jails-box" x="30" y="132" width="200" height="40"/>
                <text class="jails-accent" x="130" y="150" text-anchor="middle">FreeBSD Kernel</text>
                <text class="jails-sub" x="130" y="164" text-anchor="middle">jail(2) enforcement built in</text>

                <text class="jails-note" x="130" y="196" text-anchor="middle">1 layer. Zero daemons.</text>
                <text class="jails-note" x="130" y="210" text-anchor="middle">Near-native performance.</text>

                <!-- Docker side -->
                <text class="jails-accent" x="390" y="62" text-anchor="middle">Docker</text>

                <rect class="jails-fill-dim" x="290" y="74" width="200" height="32"/>
                <rect class="jails-box" x="290" y="74" width="200" height="32"/>
                <text class="jails-label" x="390" y="94" text-anchor="middle">Application</text>

                <line class="jails-arrow" x1="390" y1="106" x2="390" y2="116"/>

                <rect class="jails-fill-dim" x="290" y="118" width="200" height="28"/>
                <rect class="jails-box" x="290" y="118" width="200" height="28"/>
                <text class="jails-sub" x="390" y="136" text-anchor="middle">runc (OCI runtime)</text>

                <line class="jails-arrow" x1="390" y1="146" x2="390" y2="154"/>

                <rect class="jails-fill-dim" x="290" y="156" width="200" height="28"/>
                <rect class="jails-box" x="290" y="156" width="200" height="28"/>
                <text class="jails-sub" x="390" y="174" text-anchor="middle">containerd (container runtime)</text>

                <line class="jails-arrow" x1="390" y1="184" x2="390" y2="192"/>

                <rect class="jails-fill-dim" x="290" y="194" width="200" height="28"/>
                <rect class="jails-box" x="290" y="194" width="200" height="28"/>
                <text class="jails-sub" x="390" y="212" text-anchor="middle">dockerd (Docker daemon)</text>

                <line class="jails-arrow" x1="390" y1="222" x2="390" y2="230"/>

                <rect class="jails-fill-dim" x="290" y="232" width="96" height="28"/>
                <rect class="jails-box" x="290" y="232" width="96" height="28"/>
                <text class="jails-sub" x="338" y="250" text-anchor="middle">OverlayFS</text>

                <rect class="jails-fill-dim" x="394" y="232" width="96" height="28"/>
                <rect class="jails-box" x="394" y="232" width="96" height="28"/>
                <text class="jails-sub" x="442" y="250" text-anchor="middle">iptables</text>

                <line class="jails-arrow" x1="338" y1="260" x2="338" y2="272"/>
                <line class="jails-arrow" x1="442" y1="260" x2="442" y2="272"/>

                <rect class="jails-fill-dim" x="290" y="274" width="200" height="28"/>
                <rect class="jails-box" x="290" y="274" width="200" height="28"/>
                <text class="jails-sub" x="390" y="292" text-anchor="middle">cgroups + namespaces</text>

                <line class="jails-arrow" x1="390" y1="302" x2="390" y2="312"/>

                <rect class="jails-fill-dim" x="290" y="314" width="200" height="32"/>
                <rect class="jails-box" x="290" y="314" width="200" height="32"/>
                <text class="jails-label" x="390" y="334" text-anchor="middle">Linux Kernel</text>

                <text class="jails-note" x="390" y="366" text-anchor="middle">6 layers. 3 daemons.</text>
                <text class="jails-note" x="390" y="380" text-anchor="middle">Each layer adds latency and attack surface.</text>

                <!-- Bottom annotation -->
                <line class="jails-divider" x1="30" y1="396" x2="490" y2="396"/>
                <text class="jails-note" x="260" y="414" text-anchor="middle">The fastest path between a process and the kernel is no path at all.</text>
            </g>
        </svg>

        <p>This architectural directness is the source of every advantage
            that follows. Performance, security, simplicity: all three are
            consequences of the same decision. When there is nothing between
            your process and the kernel, there is nothing to go wrong,
            nothing to restart, and nothing to consume resources pretending
            to be infrastructure.</p>

        <h2>The Configuration</h2>

        <p>A jail is created with
            <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&sektion=8" target="_blank" rel="noopener"><code>jail(8)</code></a>
            and configured in
            <a href="https://man.freebsd.org/cgi/man.cgi?query=jail.conf&sektion=5" target="_blank" rel="noopener"><code>jail.conf</code></a>.
            A working configuration:</p>

        <pre><code>webserver {
    host.hostname = "web.example.com";
    ip4.addr = "10.0.0.10";
    path = "/jails/webserver";
    exec.start = "/bin/sh /etc/rc";
    exec.stop = "/bin/sh /etc/rc.shutdown";
    mount.devfs;
}</code></pre>

        <p>Seven lines. A hostname, an IP address, a filesystem path,
            start and stop commands, and device filesystem access.
            No registry to pull from. No image layers to assemble.
            No daemon to keep running in the background hoping it
            will not segfault at three in the morning. The jail starts
            when you tell it to start. It stops when you tell it to
            stop. It does not phone home, check for updates, or
            require a subscription.</p>

        <p>With <a href="https://man.freebsd.org/cgi/man.cgi?query=vnet&sektion=9" target="_blank" rel="noopener">VNET</a>,
            each jail receives its own complete network stack: its own
            routing table, its own firewall rules, its own interfaces.
            Not a NAT bridge. Not an overlay network. A proper, independent
            network stack that the kernel partitions at the same level
            as the process namespace. A jailed service binds to its
            own IP address. <code>ifconfig</code> inside the jail shows
            only that jail&#x2019;s interfaces. The networking model is
            not a workaround. It is the real thing.</p>

        <h2>The ZFS Integration</h2>

        <p>FreeBSD Jails and
            <a href="https://en.wikipedia.org/wiki/ZFS" target="_blank" rel="noopener">ZFS</a>
            are not merely compatible. They are complementary in a way
            that suggests someone designed them to work together, which,
            in the manner of all good Unix tools, nobody did. They simply
            compose.</p>

        <p>Each jail lives on a ZFS dataset. Snapshots are instantaneous
            and cost nothing until data diverges. Cloning a jail is a
            ZFS clone: a copy-on-write reference to the parent snapshot
            that consumes zero additional space until the clone writes
            its first byte. Creating a new jail from a template takes
            seconds, not minutes. Rolling back a broken update takes
            one command: <code>zfs rollback</code>. Not a rebuild.
            Not a re-pull. Not a prayer.</p>

        <p>This is not a feature that was designed by a product team
            after three quarters of user research. It is what happens
            when two tools that do their jobs correctly happen to
            operate on the same substrate. ZFS manages storage. Jails
            manage isolation. The composition is the feature. Nobody
            had to write a plugin.</p>

        <h2>The Performance</h2>

        <p>A
            <a href="https://www.diva-portal.org/smash/get/diva2:1453017/FULLTEXT01.pdf" target="_blank" rel="noopener">2020 benchmark study</a>
            measured FreeBSD Jails against Docker on identical hardware.
            The results were as subtle as a freight train. Jails achieved
            approximately 63,000 requests per second at near-native
            performance. Docker, with its daemon, its overlay filesystem,
            its NAT bridge, and its collection of userspace intermediaries,
            consumed measurably more CPU for the same workload.</p>

        <p>The reason is not that Jails are optimised. The reason is that
            there is nothing to optimise away. A jailed process makes a
            system call. The kernel checks the jail structure. The call
            proceeds or is denied. There is no daemon in the middle
            forwarding requests. There is no overlay filesystem translating
            layer references into actual file locations. There is no
            network address translation rewriting packet headers. The
            overhead of a jail is, in practical terms, the cost of a
            pointer dereference and a conditional check. On modern
            hardware, that cost is measured in nanoseconds.</p>

        <p>Docker&#x2019;s overhead, by contrast, is structural. The daemon
            must run. containerd must run. The overlay filesystem must
            resolve layers. The NAT bridge must translate addresses. Each
            layer adds latency, CPU cycles, and memory consumption. These
            are not bugs. They are architecture. They cannot be
            optimised away because they are the product itself.</p>

        <h2>The Stability</h2>

        <p>The <code>jail(2)</code> system call was introduced in FreeBSD
            4.0, released March 2000. The API has remained stable for
            twenty-five years. Configuration files written for FreeBSD 4
            remain structurally valid on FreeBSD 14. Features have been
            added (VNET networking in FreeBSD 8, hierarchical jails in
            FreeBSD 9, per-jail resource limits via
            <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&sektion=8" target="_blank" rel="noopener">rctl(8)</a>)
            but nothing has been removed. Nothing has been renamed. Nothing
            has been deprecated and replaced with a &#x201C;v2 API&#x201D;
            that requires rewriting all existing configurations.</p>

        <p>Twenty-five years of stability is not an accident. It is a
            commitment by the FreeBSD project to treat the system call
            interface as a contract. Users who configured jails in 2001
            are not punished for the crime of having adopted the
            technology early. They are rewarded with a quarter-century
            of their configurations continuing to work. In the Docker
            ecosystem, by contrast, the storage driver has changed
            three times, the networking model has been rewritten twice,
            and <code>docker-compose</code> has undergone a migration
            from Python to Go that broke every CI pipeline that relied
            on the original version.</p>

        <!-- Timeline: Jails to Docker -->
        <svg viewBox="0 0 520 320" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Timeline of containerisation. 1979: chroot. 1999: FreeBSD Jails. 2000: Jails ship in FreeBSD 4.0. 2002: Linux namespaces. 2006: cgroups. 2008: LXC. 2013: Docker. Jails predated Docker by 14 years." style="max-width: 520px; width: 100%; height: auto; margin: 2em 0;">
            <style>
                #jails-timeline .jt-title { font: 700 13px/1 'Oxanium', system-ui, sans-serif; fill: var(--text); }
                #jails-timeline .jt-sub { font: 400 10px/1 'Oxanium', system-ui, sans-serif; fill: var(--muted); }
                #jails-timeline .jt-year { font: 700 11px/1 'Oxanium', system-ui, sans-serif; fill: var(--accent); }
                #jails-timeline .jt-label { font: 600 11px/1 'Oxanium', system-ui, sans-serif; fill: var(--text); }
                #jails-timeline .jt-desc { font: 400 10px/1 'Oxanium', system-ui, sans-serif; fill: var(--muted); }
                #jails-timeline .jt-line { stroke: var(--border); stroke-width: 1.5; }
                #jails-timeline .jt-line-accent { stroke: var(--accent); stroke-width: 2; }
                #jails-timeline .jt-dot { fill: var(--accent); }
                #jails-timeline .jt-dot-dim { fill: var(--muted); }
                #jails-timeline .jt-note { font: 400 10px/1 'Oxanium', system-ui, sans-serif; fill: var(--muted); }
                #jails-timeline .jt-brace { stroke: var(--accent); stroke-width: 1; fill: none; }
                #jails-timeline .jt-brace-label { font: 600 10px/1 'Oxanium', system-ui, sans-serif; fill: var(--accent); }
            </style>
            <g id="jails-timeline">
                <text class="jt-title" x="260" y="20" text-anchor="middle">The Containerisation Timeline</text>
                <text class="jt-sub" x="260" y="36" text-anchor="middle">From chroot to Docker: 34 years, one solved problem</text>

                <!-- Timeline spine -->
                <line class="jt-line" x1="60" y1="60" x2="60" y2="278"/>

                <!-- 1979: chroot -->
                <circle class="jt-dot-dim" cx="60" cy="68" r="4"/>
                <text class="jt-year" x="80" y="72">1979</text>
                <text class="jt-label" x="136" y="72">chroot</text>
                <text class="jt-desc" x="196" y="72">Filesystem isolation only. Not a security boundary.</text>

                <!-- 1999: Jails -->
                <circle class="jt-dot" cx="60" cy="104" r="5"/>
                <text class="jt-year" x="80" y="108">1999</text>
                <text class="jt-label" x="136" y="108">FreeBSD Jails</text>
                <text class="jt-desc" x="252" y="108">Kernel-level isolation. PHK for R&amp;D Associates.</text>

                <!-- 2000: FreeBSD 4.0 -->
                <circle class="jt-dot" cx="60" cy="138" r="4"/>
                <text class="jt-year" x="80" y="142">2000</text>
                <text class="jt-label" x="136" y="142">FreeBSD 4.0</text>
                <text class="jt-desc" x="236" y="142">Jails ship. Stable API begins. Still stable.</text>

                <!-- 2002: namespaces -->
                <circle class="jt-dot-dim" cx="60" cy="172" r="4"/>
                <text class="jt-year" x="80" y="176">2002</text>
                <text class="jt-label" x="136" y="176">Linux namespaces</text>
                <text class="jt-desc" x="278" y="176">mount namespace first. 11 years of additions.</text>

                <!-- 2006: cgroups -->
                <circle class="jt-dot-dim" cx="60" cy="206" r="4"/>
                <text class="jt-year" x="80" y="210">2006</text>
                <text class="jt-label" x="136" y="210">cgroups</text>
                <text class="jt-desc" x="200" y="210">Resource limits. Google engineers. Merged 2008.</text>

                <!-- 2008: LXC -->
                <circle class="jt-dot-dim" cx="60" cy="240" r="4"/>
                <text class="jt-year" x="80" y="244">2008</text>
                <text class="jt-label" x="136" y="244">LXC</text>
                <text class="jt-desc" x="168" y="244">First Linux container runtime. Namespaces + cgroups.</text>

                <!-- 2013: Docker -->
                <circle class="jt-dot-dim" cx="60" cy="274" r="4"/>
                <text class="jt-year" x="80" y="278">2013</text>
                <text class="jt-label" x="136" y="278">Docker</text>
                <text class="jt-desc" x="192" y="278">LXC wrapper + image format + registry + marketing.</text>

                <!-- 14-year brace -->
                <path class="jt-brace" d="M46,104 L38,104 L38,274 L46,274"/>
                <text class="jt-brace-label" x="34" y="192" text-anchor="end">14 years</text>

                <!-- Bottom note -->
                <text class="jt-note" x="260" y="304" text-anchor="middle">Jails solved the problem in 1999. Docker solved the marketing in 2013.</text>
            </g>
        </svg>

        <h2>The Contrast</h2>

        <p>To run a Docker container on Linux, one requires: <code>dockerd</code>
            (the Docker daemon), <code>containerd</code> (the container
            runtime daemon), <code>runc</code> (the OCI runtime), an
            overlay filesystem driver, a NAT bridge for networking,
            <code>iptables</code> rules for port mapping, and
            <code>cgroups</code> plus <code>namespaces</code> for the
            actual isolation that the kernel provides but Docker wraps
            in three layers of indirection.</p>

        <p>To run a FreeBSD jail, one requires: the kernel. Which is
            already running.</p>

        <p>This is not a simplification for rhetorical effect. A jail
            starts with <code>jail -c</code> or <code>service jail start</code>.
            There is no daemon to install. There is no service to enable.
            There is no socket to worry about
            (the Docker socket is, infamously, a root-equivalent
            attack surface). The kernel provides isolation because that is
            what kernels do. Docker provides isolation by running three
            daemons that collectively ask the kernel to do what it
            could have done directly, had anyone thought to use the
            system calls that already existed.</p>

        <p>The irony is not lost on the FreeBSD community. Linux
            needed three separate kernel subsystems (namespaces, cgroups,
            seccomp) developed over eleven years, plus a userspace daemon
            stack, to approximate what FreeBSD shipped as a single,
            coherent kernel feature in 2000. The Linux approach is not
            wrong; it works. But it is the difference between a room
            designed with a door and a room where someone cut a hole
            in the wall, fitted a frame, attached hinges, and called
            it a design pattern.</p>

        <h2>The Quiet Adoption</h2>

        <p>FreeBSD Jails have no marketing department. They have no
            corporate sponsor pushing them at conferences. They have no
            logo, no certification programme, no &#x201C;Jail
            Desktop&#x201D; for developers who want to run their IDE
            inside a container for reasons that remain mysterious.
            They have, instead, a
            <a href="https://docs.freebsd.org/en/books/handbook/jails/" target="_blank" rel="noopener">handbook chapter</a>
            and a quarter-century of production deployments.</p>

        <p>Netflix serves video to 260 million subscribers using
            FreeBSD and jails on bare metal. Not because FreeBSD has
            better branding, but because when you are delivering
            terabits per second, the overhead of a container daemon
            is not a rounding error; it is a line item on the
            infrastructure bill. The
            <a href="https://en.wikipedia.org/wiki/PlayStation_4" target="_blank" rel="noopener">PlayStation 4</a>
            and PlayStation 5 run on a FreeBSD-derived operating system.
            WhatsApp, before its acquisition, ran on FreeBSD. These are
            not hobby deployments. They are systems where performance
            and stability are not negotiable, and where the industry&#x2019;s
            preferred container runtime was quietly evaluated and
            quietly declined.</p>

        <h2>The Lesson</h2>

        <p>FreeBSD Jails are technically beautiful not because they are
            old, though twenty-five years of stability is its own form
            of beauty. They are beautiful because they are <em>correct</em>.
            The kernel is the right place for isolation. A system call is
            the right interface. ZFS is the right storage layer. None of
            this required a daemon, a registry, a build tool, an
            orchestrator, or a conference talk explaining why you need
            all five.</p>

        <p>The industry chose Docker. Not because Docker is technically
            superior, but because Docker is easier to sell. It has
            a logo. It has a company. It has a certification. It
            solves a problem that Linux created (no standard base system)
            by shipping the entire operating system with every
            application, which is the sort of solution that only
            makes sense if you have never seen the alternative.</p>

        <p>The alternative has been running since 2000. It has not
            broken. It has not changed its API. It has not been
            acquired, relicensed, or pivoted into a platform play.
            It sits in the FreeBSD kernel, one system call deep,
            doing precisely what it was designed to do.</p>

        <blockquote>
            <p>One system call. Zero daemons. Twenty-five years. No breaking
                changes. The most elegant containerisation is the one that
                never needed a container runtime.</p>
        </blockquote>

        <aside class="vv-aside">
            <p><strong>The numbers, for those who appreciate receipts</strong></p>
            <p>FreeBSD Jails were developed in 1999, fourteen years before
                Docker. Poul-Henning Kamp built them for
                <a href="https://klarasystems.com/articles/freebsd-jails-the-beginning-of-freebsd-containers/" target="_blank" rel="noopener">R&amp;D Associates</a>,
                a hosting provider that needed secure isolation without VM
                overhead. A
                <a href="https://www.diva-portal.org/smash/get/diva2:1453017/FULLTEXT01.pdf" target="_blank" rel="noopener">2020 benchmark</a>
                measured approximately 63,000 requests per second at near-native
                performance, with significantly lower CPU usage than Docker on
                identical hardware. The <code>jail(2)</code> API has remained
                stable since FreeBSD 4.0 (March 2000). The
                <a href="https://papers.freebsd.org/2000/phk-jails/" target="_blank" rel="noopener">original paper</a>
                by Kamp and Watson remains the definitive reference. No
                commercial interests. No aggressive marketing. Just a kernel
                feature that works.</p>
        </aside>
    </div>

    <footer class="vv-article-footer">
        <a href="/blog">&#x2190; All articles</a>
    </footer>
</article>
{( endslot )}